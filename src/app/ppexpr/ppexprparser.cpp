// This file was generated by qlalr - DO NOT EDIT!

#line 99 "ppexpr.g"

#include "ppexprparser.h"
#include <macrotable.h>
#include "ppexpr-lex.inc"

PPExprParser::PPExprParser()
:   stack_size(0),
    sym_stack(0),
    state_stack(0),
    m_macroTable(0)
{
}

PPExprParser::~PPExprParser()
{
    if (stack_size) {
        qFree(sym_stack);
        qFree(state_stack);
    }
}

inline void PPExprParser::reallocateStack()
{
    if (!stack_size)
        stack_size = 128;
    else
        stack_size <<= 1;

    sym_stack = reinterpret_cast<Value*> (qRealloc(sym_stack, stack_size * sizeof(Value)));
    state_stack = reinterpret_cast<int*> (qRealloc(state_stack, stack_size * sizeof(int)));
}

bool PPExprParser::parse(const char* str)
{
    const int INITIAL_STATE = 0;
    int yytoken = -1;

    reallocateStack();

    tos = 0;
    m_errorMessage.clear();
    state_stack[++tos] = INITIAL_STATE;
    yyInputBuffer = yy_scan_string(str);
    if (!yyInputBuffer) {
        m_errorMessage = "Can't create lexer's input buffer.";
        return false;
    }

    while (true)
    {
        if (yytoken == -1 && - TERMINAL_COUNT != action_index [state_stack [tos]]) {
            yytoken = yylex();
//            printf("*** yylex %d\n", yytoken);
        }

        int act = t_action(state_stack [tos], yytoken);

        if (act == ACCEPT_STATE) {
            yy_delete_buffer((YY_BUFFER_STATE)yyInputBuffer);
            return true;
        }

        else if (act > 0) {
            if (++tos == stack_size)
                reallocateStack();

            sym_stack [tos] = yylval;
            state_stack [tos] = act;
            yytoken = -1;
        }

        else if (act < 0)
        {
            int r = - act - 1;

//            int ridx = rule_index [r];
//            printf ("*** reduce using rule %d %s ::=", r + 1, spell[rule_info [ridx]]);
//            ++ridx;
//            for (int i = ridx; i < ridx + rhs [r]; ++i)
//            {
//                int symbol = rule_info [i];
//                if (const char *name = spell [symbol])
//                    printf (" %s", name);
//                else
//                    printf (" #%d", symbol);
//            }
//            printf ("\n");

            tos -= rhs [r];
            act = state_stack [tos++];

            switch (r) {

#line 196 "ppexpr.g"

    case 2: // term0
        sym(1).num = (sym(1).num != 0 && sym(3).num != 0) ? 1 : 0;
        break;

#line 203 "ppexpr.g"

    case 3: // term0
        sym(1).num = (sym(1).num != 0 || sym(3).num != 0) ? 1 : 0;
        break;

#line 210 "ppexpr.g"

    case 4: // term0
        sym(1).num &= sym(3).num;
        break;

#line 217 "ppexpr.g"

    case 5: // term0
        sym(1).num |= sym(3).num;
        break;

#line 227 "ppexpr.g"

    case 8: { // strterm1
        QByteArray* lhs = sym(1).str;
        QByteArray* rhs = sym(3).str;
        sym(1).num = (*lhs == *rhs) ? 1 : 0;
        delete lhs;
        delete rhs;
        break;
    }

#line 239 "ppexpr.g"

    case 9: { // strterm1
        QByteArray* lhs = sym(1).str;
        QByteArray* rhs = sym(3).str;
        sym(1).num = (*lhs == *rhs) ? 0 : 1;
        delete lhs;
        delete rhs;
        break;
    }

#line 252 "ppexpr.g"

    case 11: // term2
        sym(1).num = (sym(1).num == sym(3).num);
        break;

#line 259 "ppexpr.g"

    case 12: // term2
        sym(1).num = (sym(1).num != sym(3).num);
        break;

#line 266 "ppexpr.g"

    case 13: // term2
        sym(1).num = (sym(1).num < sym(3).num);
        break;

#line 273 "ppexpr.g"

    case 14: // term2
        sym(1).num = (sym(1).num > sym(3).num);
        break;

#line 280 "ppexpr.g"

    case 15: // term2
        sym(1).num = (sym(1).num <= sym(3).num);
        break;

#line 287 "ppexpr.g"

    case 16: // term2
        sym(1).num = (sym(1).num >= sym(3).num);
        break;

#line 295 "ppexpr.g"

    case 18: // term3
        sym(1).num <<= sym(3).num;
        break;

#line 302 "ppexpr.g"

    case 19: // term3
        sym(1).num >>= sym(3).num;
        break;

#line 310 "ppexpr.g"

    case 21: // term4
        sym(1).num += sym(3).num;
        break;

#line 317 "ppexpr.g"

    case 22: // term4
        sym(1).num -= sym(3).num;
        break;

#line 325 "ppexpr.g"

    case 24: // term5
        sym(1).num *= sym(3).num;
        break;

#line 332 "ppexpr.g"

    case 25: { // term5
        const int rhs = sym(3).num;
        if (rhs == 0) {
            m_errorMessage = "division by zero";
            yy_delete_buffer((YY_BUFFER_STATE)yyInputBuffer);
            return false;
        }
        sym(1).num /= rhs;
        break;
    }

#line 346 "ppexpr.g"

    case 26: // term5
        sym(1).num %= sym(3).num;
        break;

#line 354 "ppexpr.g"

    case 28: // term6
        sym(1).num = -sym(1).num;
        break;

#line 361 "ppexpr.g"

    case 29: // term6
        sym(1).num = ~sym(1).num;
        break;

#line 368 "ppexpr.g"

    case 30: // term6
        sym(1).num = (sym(1).num == 0) ? 1 : 0;
        break;

#line 376 "ppexpr.g"

    case 32: // primary
        sym(1).num = sym(2).num;
        break;

#line 382 "ppexpr.g"

            } // switch

            state_stack [tos] = nt_action (act, lhs [r] - TERMINAL_COUNT);
        }
        else
        {
            // ### ERROR RECOVERY HERE
            break;
        }
    }

    m_errorMessage = "Syntax Error";
    yy_delete_buffer((YY_BUFFER_STATE)yyInputBuffer);
    return false;
}
