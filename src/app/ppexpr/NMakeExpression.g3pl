grammar NMakeExpression;

options {
	language = C;
}

tokens {
    BOOL_AND = '&&';
    BOOL_OR  = '||';
    BIT_AND = '&';
    BIT_OR  = '|';
    EQUAL   = '==';
    NOT_EQUAL = '!=';
    LESS_THAN  = '<';
    GREATER_THAN = '>';
    EQUAL_OR_LESS_THAN = '<=';
    EQUAL_OR_GREATER_THAN = '>=';
    SHIFT_LEFT = '<<';
    SHIFT_RIGHT = '>>';
    PLUS     = '+' ;
    MINUS    = '-' ;
    MULT     = '*' ;
    DIV      = '/' ;
    MOD      = '%';
    BIT_NOT = '~';
    BOOL_NOT = '!';
}

@header {
}

@members {
    typedef int (*stringCallback)(void*, pANTLR3_STRING);
    void* _caller;
    stringCallback _isMacroDefined;
    stringCallback _isFileExisting;
    
    static int isMacroDefined(pANTLR3_STRING macro)
    {
        return ((stringCallback)(_isMacroDefined))(_caller, macro);
    }
    
    static int isFileExisting(pANTLR3_STRING filename)
    {
        return ((stringCallback)(_isFileExisting))(_caller, filename);
    }
}

/*------------------------------------------------------------------
 * PARSER RULES
 *------------------------------------------------------------------*/

expr [void* caller, void* cbIsMacroDefined, void* cbFileExisting]
returns [int result] :
        {
            _caller = caller;
            _isMacroDefined = cbIsMacroDefined;
            _isFileExisting = cbFileExisting;
        }
    value=term0
        {
            result = value;
        }
    ;

term0 returns [int result] :
    lhs=term1
        {
            result = lhs;
        }
    ( op=(BOOL_AND | BOOL_OR | BIT_AND | BIT_OR)  rhs=term1
        {
            switch (op->getType(op))
            {
            case BOOL_AND:
                result = (result != 0 && rhs != 0) ? 1 : 0;
                break;
            case BOOL_OR:
                result = (result != 0 || rhs != 0) ? 1 : 0;
                break;
            case BIT_AND:
                result &= rhs;
                break;
            case BIT_OR:
                result |= rhs;
                break;
            }
        }
    )*
|	   lhs=STRING op=(EQUAL | NOT_EQUAL) rhs=STRING
        {
            pANTLR3_STRING s1 = lhs->getText(lhs);
            pANTLR3_STRING s2 = rhs->getText(rhs);
            ANTLR3_UINT32 cmp = s1->compareS(s1, s2);
            switch (op->getType(op))
            {
                case EQUAL:
                    result = (cmp == 0);
                    break;
                case NOT_EQUAL:
                    result = (cmp != 0);
                    break;
            }
        }
	;


term1 returns [int result] :
    lhs=term2
        {
            result = lhs;
        }
    ( op=(EQUAL | NOT_EQUAL | LESS_THAN | GREATER_THAN | EQUAL_OR_LESS_THAN | EQUAL_OR_GREATER_THAN) rhs=term2
        {
            switch (op->getType(op))
            {
            case EQUAL:
                result = (result == rhs);
                break;
            case NOT_EQUAL:
                result = (result != rhs);
                break;
            case LESS_THAN:
                result = (result < rhs);
                break;
            case GREATER_THAN:
                result = (result > rhs);
                break;
            case EQUAL_OR_LESS_THAN:
                result = (result <= rhs);
                break;
            case EQUAL_OR_GREATER_THAN:
                result = (result >= rhs);
                break;
            }
        }
    )*
    ;

term2 returns [int result] :
    lhs=term3
        {
            result = lhs;
        }
    ( op=(SHIFT_LEFT | SHIFT_RIGHT) rhs=term3
        {
            switch (op->getType(op))
            {
            case SHIFT_LEFT:
                result = (result << rhs);
                break;
            case SHIFT_RIGHT:
                result = (result >> rhs);
                break;
            }
        }
    )*
    ;

term3 returns [int result]:
    lhs=term4
        {
            result = lhs;
        }
    ( op=(PLUS | MINUS) rhs=term4
        {
            switch (op->getType(op))
            {
            case PLUS:
                result += rhs;
                break;
            case MINUS:
                result -= rhs;
                break;
            }
        }
    )*
    ;

term4 returns [int result]:
    lhs=term5
        {
            result = lhs;
        }
    ( op=(MULT | DIV | MOD) rhs=term5
        {
            switch (op->getType(op))
            {
            case MULT:
                result *= rhs;
                break;
            case DIV:
                result /= rhs;
                break;
            case MOD:
                result = result \% rhs;
                break;
            }
        }
    )*
    ;

term5 returns [int result]:
    op=(MINUS | BIT_NOT | BOOL_NOT)? v=primary
        {
            if (!op)
                result = v;
            else
                switch (op->getType(op))
                {
                case MINUS:
                    result = -v;
                    break;
                case BIT_NOT:
                    result = ~v;
                    break;
                case BOOL_NOT:
                    result = (v != 0) ? 0 : 1;
                    break;
                }
        }
    ;

primary returns [int result]:
    n=NUMBER
        {
            pANTLR3_STRING text = n->getText(n);
            result = text->toInt32(text);
        }
|   DEFINED '(' t=(STRING | IDENTIFIER) ')'
        {
            result = isMacroDefined(t->getText(t));
        }
|   t=EXIST
        {
            result = isFileExisting(t->getText(t));
        }
|   '(' n2=term0 ')'
        {
            result = n2;
        }
;

/*------------------------------------------------------------------
 * LEXER RULES
 *------------------------------------------------------------------*/

NUMBER          : (DIGIT)+ ;
WHITESPACE      : ( SPACE | '\r' | '\n'| '\u000C' )+ 	{ $channel = HIDDEN; } ;
fragment LETTER : 'a'..'z'|'A'..'Z';
fragment DIGIT  : '0'..'9' ;
fragment SPACE  : '\t' | ' ';
EXIST           : 'EXIST' SPACE* '(' ( ~')' )+ ')';
DEFINED         : 'DEFINED';
IDENTIFIER      : LETTER (LETTER | DIGIT)*;
STRING          : ('"' (~'"')* '"')+;
//MACRO           : '$(' (~')')+ ')';
